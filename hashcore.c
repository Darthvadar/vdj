#include "hashcore.h"

using namespace std;

unsigned short getNucleotide(char ch){
    
    switch(ch) {
        case 'a':
        case 'A': return A;
        case 't':
        case 'T': return T;
        case 'c':
        case 'C': return C;
        case 'g': 
        case 'G': return G;
        default:  return 5;
    }
}

// This code was not generated by hand. Modifying it is ill-advised.
inline void runCombs( map<unsigned long, int>* hm, unsigned long xx, unsigned long mask, int ii ){

if(!((0x3B2D7 & mask)) && (ii >  18)) { insertBump(hm, ((0x38000 & xx) >> 6) | ((0x3000 & xx) >> 5) | ((0x200 & xx) >> 3) | ((0xc0 & xx) >> 2) | ((0x10 & xx) >> 1) | ((0x7 & xx) >> 0)); }
if(!((0x3C44D7 & mask)) && (ii >  22)) { insertBump(hm, ((0x3c0000 & xx) >> 10) | ((0x4000 & xx) >> 7) | ((0x400 & xx) >> 4) | ((0xc0 & xx) >> 2) | ((0x10 & xx) >> 1) | ((0x7 & xx) >> 0)); }
if(!((0xFFF & mask)) && (ii >  12)) { insertBump(hm, ((0xfff & xx) >> 0)); }
if(!((0x1A18AF & mask)) && (ii >  21)) { insertBump(hm, ((0x180000 & xx) >> 10) | ((0x20000 & xx) >> 9) | ((0x1800 & xx) >> 5) | ((0x80 & xx) >> 2) | ((0x20 & xx) >> 1) | ((0xf & xx) >> 0)); }
if(!((0x7747 & mask)) && (ii >  15)) { insertBump(hm, ((0x7000 & xx) >> 5) | ((0x700 & xx) >> 4) | ((0x40 & xx) >> 3) | ((0x7 & xx) >> 0)); }

    return;
}

inline void insertBump(map<unsigned long, int>* mp, unsigned long key){

    map<unsigned long, int>::iterator itr = mp->lower_bound(key);

    // Are we in the right place?
    if( (*itr).first == key ){
        (*itr).second += 1; // bump the count if we are
    } else {
        // otherwise add it to the set
        mp->insert(itr, pair<unsigned long, int>(key, 1));
    }
    return;
}

// add one to the observations
void pseudocount(map<unsigned long, int>* mp){
    map<unsigned long, int>::iterator mp_itr;

    for( mp_itr = mp->begin(); mp_itr != mp->end(); mp_itr++ ){
        (*mp_itr) += 1;
    }

    return;
}

map<unsigned long, int>* extractFeatures(char* seq, map<unsigned long, int> *res = NULL){
    int len = strlen(seq);

    if( !res ){
        res = new map<unsigned long, int>();
    }

    unsigned long acc = 0;
    unsigned long nmask = 0;
    unsigned short nuc;
    
    int ii;
    for( ii = 0; ii < len; ++ii) {
        nuc = getNucleotide(seq[ii]);
        acc <<= 2;
        acc += nuc % 5;
        
        nmask <<= 2;
        if( nuc > G ){
            nmask += 3;
        }

        runCombs(res, acc, nmask, ii);    
    }
    
    return res;
}

map<unsigned long, int>* makeFeatureSet(list<char*> sequences){

    list<char*>::iterator seq_itr;
    map<unsigned long, int> *featureSet = new map<unsigned long, int>();

    for( seq_itr = sequences.begin(); seq_itr != sequences.end(); seq_itr++ ){
        extractFeatures(*seq_itr, featureSet);
    }

    return featureSet;
}

/*
static PyObject *hashcore_seq2hash( PyObject *self, PyObject *args ) {
    // define data
    
    // parse python objects
    if ( !PyArg_ParseTuple(args,"", ) ) {
        return NULL ;
    }
    
    // perform computation
    
    // build python value
    return Py_BuildValue( ) ;   // we possibly want to return a dictionary here
}

static PyMethodDef hashcoremethods[] = {
    {"seq2hash", hashcore_seq2hash, METH_VARARGS},
} ;

void initalignmentcore() {
    Py_InitModule( "hashcore", hashcoremethods ) ;
    import_array();
}
*/


int main(int argc, char** argv){
    
    char* seq = "CGATATGCACGCTCTCGACGCGCGACGCACGACGACACACGAGAGNGNGNGACGACGACGGACGACGA";
    list<char*> sequences;
    sequences.push_back(seq);
    map<unsigned long, int>* f = extractFeatures(seq);

    map<unsigned long, int>::iterator itr;

    for( itr = f->begin(); itr != f->end() ; itr++){
        printf("0x%X: %d\n", (unsigned int) (*itr).first, (*itr).second);
    }

    delete f;
    return 0;

}
